\hypertarget{b2_collision_8cpp}{}\section{E\+:/\+Uni/6.Semester/\+Grundkurs\+\_\+\+C++/01-\/\+Race\+Game/\+Box2\+D/\+Box2\+D/\+Collision/b2\+Collision.cpp File Reference}
\label{b2_collision_8cpp}\index{E:/Uni/6.Semester/Grundkurs\_C++/01-\/RaceGame/Box2D/Box2D/Collision/b2Collision.cpp@{E:/Uni/6.Semester/Grundkurs\_C++/01-\/RaceGame/Box2D/Box2D/Collision/b2Collision.cpp}}
{\ttfamily \#include \char`\"{}Box2\+D/\+Collision/b2\+Collision.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}Box2\+D/\+Collision/b2\+Distance.\+h\char`\"{}}\newline
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{b2_collision_8cpp_a401e2747d276e9fbfd131989e02ff568}{b2\+Get\+Point\+States}} (\mbox{\hyperlink{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663d}{b2\+Point\+State}} state1\mbox{[}\mbox{\hyperlink{b2_settings_8h_aa5f44cc9edf711433dea2b2ec94f3c42}{b2\+\_\+max\+Manifold\+Points}}\mbox{]}, \mbox{\hyperlink{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663d}{b2\+Point\+State}} state2\mbox{[}\mbox{\hyperlink{b2_settings_8h_aa5f44cc9edf711433dea2b2ec94f3c42}{b2\+\_\+max\+Manifold\+Points}}\mbox{]}, const \mbox{\hyperlink{structb2_manifold}{b2\+Manifold}} $\ast$manifold1, const \mbox{\hyperlink{structb2_manifold}{b2\+Manifold}} $\ast$manifold2)
\item 
\mbox{\hyperlink{b2_settings_8h_a43d43196463bde49cb067f5c20ab8481}{int32}} \mbox{\hyperlink{b2_collision_8cpp_a8b36e651798f55f2533f9837462ded41}{b2\+Clip\+Segment\+To\+Line}} (\mbox{\hyperlink{structb2_clip_vertex}{b2\+Clip\+Vertex}} v\+Out\mbox{[}2\mbox{]}, const \mbox{\hyperlink{structb2_clip_vertex}{b2\+Clip\+Vertex}} v\+In\mbox{[}2\mbox{]}, const \mbox{\hyperlink{structb2_vec2}{b2\+Vec2}} \&normal, \mbox{\hyperlink{b2_settings_8h_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}} offset, \mbox{\hyperlink{b2_settings_8h_a43d43196463bde49cb067f5c20ab8481}{int32}} vertex\+IndexA)
\begin{DoxyCompactList}\small\item\em Clipping for contact manifolds. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{b2_collision_8cpp_ae7601420d0b42c1ee494e879dd2009a5}{b2\+Test\+Overlap}} (const \mbox{\hyperlink{classb2_shape}{b2\+Shape}} $\ast$shapeA, \mbox{\hyperlink{b2_settings_8h_a43d43196463bde49cb067f5c20ab8481}{int32}} indexA, const \mbox{\hyperlink{classb2_shape}{b2\+Shape}} $\ast$shapeB, \mbox{\hyperlink{b2_settings_8h_a43d43196463bde49cb067f5c20ab8481}{int32}} indexB, const \mbox{\hyperlink{structb2_transform}{b2\+Transform}} \&xfA, const \mbox{\hyperlink{structb2_transform}{b2\+Transform}} \&xfB)
\begin{DoxyCompactList}\small\item\em Determine if two generic shapes overlap. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\Hypertarget{b2_collision_8cpp_a8b36e651798f55f2533f9837462ded41}\label{b2_collision_8cpp_a8b36e651798f55f2533f9837462ded41}} 
\index{b2Collision.cpp@{b2Collision.cpp}!b2ClipSegmentToLine@{b2ClipSegmentToLine}}
\index{b2ClipSegmentToLine@{b2ClipSegmentToLine}!b2Collision.cpp@{b2Collision.cpp}}
\subsubsection{\texorpdfstring{b2ClipSegmentToLine()}{b2ClipSegmentToLine()}}
{\footnotesize\ttfamily \mbox{\hyperlink{b2_settings_8h_a43d43196463bde49cb067f5c20ab8481}{int32}} b2\+Clip\+Segment\+To\+Line (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structb2_clip_vertex}{b2\+Clip\+Vertex}}}]{v\+Out\mbox{[}2\mbox{]},  }\item[{const \mbox{\hyperlink{structb2_clip_vertex}{b2\+Clip\+Vertex}}}]{v\+In\mbox{[}2\mbox{]},  }\item[{const \mbox{\hyperlink{structb2_vec2}{b2\+Vec2}} \&}]{normal,  }\item[{\mbox{\hyperlink{b2_settings_8h_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}}}]{offset,  }\item[{\mbox{\hyperlink{b2_settings_8h_a43d43196463bde49cb067f5c20ab8481}{int32}}}]{vertex\+IndexA }\end{DoxyParamCaption})}



Clipping for contact manifolds. 

\mbox{\Hypertarget{b2_collision_8cpp_a401e2747d276e9fbfd131989e02ff568}\label{b2_collision_8cpp_a401e2747d276e9fbfd131989e02ff568}} 
\index{b2Collision.cpp@{b2Collision.cpp}!b2GetPointStates@{b2GetPointStates}}
\index{b2GetPointStates@{b2GetPointStates}!b2Collision.cpp@{b2Collision.cpp}}
\subsubsection{\texorpdfstring{b2GetPointStates()}{b2GetPointStates()}}
{\footnotesize\ttfamily void b2\+Get\+Point\+States (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663d}{b2\+Point\+State}}}]{state1\mbox{[}b2\+\_\+max\+Manifold\+Points\mbox{]},  }\item[{\mbox{\hyperlink{b2_collision_8h_a0a894e3715ce8c61b7958dd6e083663d}{b2\+Point\+State}}}]{state2\mbox{[}b2\+\_\+max\+Manifold\+Points\mbox{]},  }\item[{const \mbox{\hyperlink{structb2_manifold}{b2\+Manifold}} $\ast$}]{manifold1,  }\item[{const \mbox{\hyperlink{structb2_manifold}{b2\+Manifold}} $\ast$}]{manifold2 }\end{DoxyParamCaption})}

Compute the point states given two manifolds. The states pertain to the transition from manifold1 to manifold2. So state1 is either persist or remove while state2 is either add or persist. \mbox{\Hypertarget{b2_collision_8cpp_ae7601420d0b42c1ee494e879dd2009a5}\label{b2_collision_8cpp_ae7601420d0b42c1ee494e879dd2009a5}} 
\index{b2Collision.cpp@{b2Collision.cpp}!b2TestOverlap@{b2TestOverlap}}
\index{b2TestOverlap@{b2TestOverlap}!b2Collision.cpp@{b2Collision.cpp}}
\subsubsection{\texorpdfstring{b2TestOverlap()}{b2TestOverlap()}}
{\footnotesize\ttfamily bool b2\+Test\+Overlap (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classb2_shape}{b2\+Shape}} $\ast$}]{shapeA,  }\item[{\mbox{\hyperlink{b2_settings_8h_a43d43196463bde49cb067f5c20ab8481}{int32}}}]{indexA,  }\item[{const \mbox{\hyperlink{classb2_shape}{b2\+Shape}} $\ast$}]{shapeB,  }\item[{\mbox{\hyperlink{b2_settings_8h_a43d43196463bde49cb067f5c20ab8481}{int32}}}]{indexB,  }\item[{const \mbox{\hyperlink{structb2_transform}{b2\+Transform}} \&}]{xfA,  }\item[{const \mbox{\hyperlink{structb2_transform}{b2\+Transform}} \&}]{xfB }\end{DoxyParamCaption})}



Determine if two generic shapes overlap. 

